using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MovieLibrary
{
    // ABstract Class required if ANY member is abstract
    //  1. Cannot be instantiated
    //  2. Must Derive from it
    //  3. Must implement all abstract members
    public abstract class MovieDatabase : IMovieDatabase
    {
        //public void Foo () { }

        // Array - T[] = type name followed with square brackets
        public Movie Add ( Movie movie )
        {
            // Exception type is teh base type of all exceptions
            // Arguments should always fail with Argument exceptions
            // Exception -> ArgumentException
            // Argument Exception - reports problems with data passed to a method
            // ArgumentNullException -> argument is null and shouldnt be
            // ArgumentOutOfRangeException -> argument is outside of specified range
            // Validation Exception -> IValidateObject fails
            // InvalidOperationException -> The operation is not currently valid, but may be in the future
            // System Exception -> Only generated by runtime
            //      NullRefernceException -> null is on left side of member access (null.???)
            //      StackOverflowException -> Stack overflowed
            //      OutOfMemoryException -> out of memory

            // Throw an expression using throw exception
            //      throw-expression ::- throw E
            //              E must be Exception
            //if (movie == null)
            //    throw new ArgumentNullException(nameof(movie));            // Argument is null and shouldn't be, pretty much all reference types

            // Movie is valid
            //new ObjectValidator().ValidateFullObject(movie);
            ObjectValidator.ValidateFullObject(movie);

            // if (results.Count() > 0)
            // {
            //  foreach (var result in results)
            //  {
            //     error = result.ErrorMessage;
            //     return null;
            // }
            //  }
            //TODO Movie is valid, name is unique
            var existing = GetByName(movie.Name);
            if (existing != null)
                throw new InvalidOperationException("Movie must be unique");
            // {
            //     error = "Movie must be unique!";
            //     return null;
            // }
            try
            {
                return AddCore(movie);
            } catch (Exception e)
            {
                //throwing a new exception
                throw new InvalidOperationException("Add Failed", e);
            }
        }

        protected abstract Movie AddCore ( Movie movie );

        protected abstract void DeleteCore ( int id );
        protected virtual Movie GetByName ( string name ) => GetAll().FirstOrDefault(x => String.Compare(x.Name, name, true) == 0);
      
        //protected virtual Movie GetByName ( string name )
        //{
        //    return GetAll().FirstOrDefault(x => String.Compare(x.Name, name, true) == 0);
        //    //foreach (var movie in GetAll())
        //    //{
        //    //    if (String.Compare(movie.Name, name, true) == 0)
        //    //        return movie;
        //    //}

        //    //return null;
        //}

        protected abstract IEnumerable<Movie> GetAllCore ();

        protected abstract Movie GetByIdCore ( int id );

        protected abstract void UpdateCore ( int id, Movie movie );

        public void Delete ( int id )
        {
            // Id >  0
            if (id <= 0)
                throw new ArgumentOutOfRangeException(nameof(id), "Id must be greater than zero");
            try
            {
                DeleteCore(id);
            } catch (Exception e)
            {
                //throwing a new exception
                throw new InvalidOperationException("Add Failed", e);
            }

            //for (var index = 0; index < _movies.Length; ++index)
            //{
            //    // Array element access ;;= V[int]
            //    //if (_movies[index] != null && _movies[index].Id == id)
            //    if (_movies[index]?.Id == id) // null conditional  ?.  If instance != null access the member
            //    {
            //        _movies[index] = null;
            //        return;
            //    }
            //}
            }

            // Use IEnumerable<T> for read-only lists of items
            //public Movie[] GetAll ()
            public IEnumerable<Movie> GetAll ()
            {
                // object value = null;
                // value.ToString();
                return GetAllCore();
                try
                {
                    return GetAllCore();
                } catch (Exception e)
                {
                    //throwing a new exception
                    throw new InvalidOperationException("GetAll Failed", e);
                }


            }

            public Movie Get ( int id )
            {
                if (id <= 0)
                    throw new ArgumentOutOfRangeException(nameof(id), "Id must be greater than zero");
                try
                {
                    return GetByIdCore(id);
                } catch (Exception e)
                {
                    //throwing a new exception
                    throw new InvalidOperationException("GetById Failed", e);
                }
            }

            public void Update ( int id, Movie movie )
            {
                //Validate ID
                if (id <= 0)
                    throw new ArgumentOutOfRangeException(nameof(id), "Id must be greater than zero");
                if (movie == null)
                    throw new ArgumentNullException(nameof(movie));
                // Movie exists
                // new ObjectValidator().ValidateFullObject(movie);
                // if (results.Count() > 0)
                // {
                //     foreach (var result in results)
                //    {
                //        return null;
                //    }
                // }
                //TODO Movie is valid, name is unique
                var existing = GetByName(movie.Name);
                if (existing != null && existing.Id != id)
                    throw new InvalidOperationException("Movie must be unique!");

                // TODO: Generalize exceptions
                try
                {
                    UpdateCore(id, movie);
                } catch (Exception e)
                {
                    //throwing a new exception
                    throw new InvalidOperationException("GetById Failed", e);
                }
            }
        }

    // Dataset vs. Datareader ( Beffured vs streamed)
    // 
    // A = Advantage, D = Disadvantage
    //
    // Dataset:
    // A: Disconnected from database
    // A: Discoverable - column names, types, nullable and relationships
    // A: Pre-defined business objects
    // A: Modifiable
    // D: Very high memory overhead ( requires 2x as much storage for column data) (< 1k)
    //
    // Data Readers:
    // A: No memory Overhead
    // A: Fast
    // A: Store in your business objects
    // D: Must know the data
    // D: Cannot modify data : Read - Only
    // 
    // Use a Datareader unless you have need for a feature not available in a data reader
    // USe a Dataset when you need very small sets of fixed data where no business logic is needed





        //Non-generic
        //   ArrayList - list of objects (lose strong typing known to C#)
        // Generic Types
        //   List<T> : where T equals any type
        





    // LINQ - Language Integrated Natural Query
    // Deffered Excecution -> Next Element is not retrieved until needed 
    //   Directory.GetFiles() -> string[]  (not)
    //   Directory.EnumerateFiles() -> IEnumerable<string>  (deffered)
    //
    // Common extension methods for INumerable<T>
    //  Convesion
    //   ToArray() -> T[]
    //   ToList() -> List<T>
    //  Casting
    //   OfType<T>() -> Returns IEnumerable<T> of any items that are compatible with T
    //   Cast<T> -> Return IENumerable<T> but crashes if anything doesn't match type
    //  Get Item (not deferred) ->
    // First/ FirstOrDefault -> Gets first item (if any)
    // Last/ LastOrDefault -> Gets Last item (if any)
    // Single/ SingleOrDefault -> Gets only items (if any)
    //  Query -> IEnumerable<T> (replace foreach)
    //   Where(condition) -> IEnumerable<T>
    //   OrderBy(member) -> IEnumerable <T> orderd by member
    //   Select<T> -> grouped IEnumerable<T>
    //   Join() -> IEnumerable<?>
    //
    //
    //
    // Delegates (function object, functor) - the type that represents any method that returns a bool
    //      Treat a function as data
    //      Action -> void fx ()
    //      Action<T1, T2> -> void fx ( t1, T2 )
    //      Func<T, R> -> R fx(T)
    //      Func<T1, T2, R> -> R fx (T1, T2 )

    // Lambda expressions / anonymous methods
    //  Method that has no name ( can't be called due to being nameless)
    //  Can only be called with a delegate
    //  parameters => expression


    // Expression bodies(limited to methods, constructors, operators, properties)
    //    method => E;
    //    T property => {get => E; set => S;}
    //    T property => E;
    //      Replaces a method body that has a single return statement (compiler rewrites to regular method)

    // LINQ syntax
    //      from x in IEnumerable<T>
    //      [where lambda expression]
    //      [orderby member, member]
    //      select E

    }




